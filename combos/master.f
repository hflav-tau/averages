************************************************************************
*
*     "Master" routines for COMBOS program
*
*     Olivier Schneider, CERN/PPE-ALE
*
*     Version 1.00, December  6, 1996:
*     -- original release
*     Version 1.10, December 10, 1996:
*     -- check that NMEAS does not exceed MMEAS
*     -- improved printout (statistical correlations, ...)
*     -- perform symmetrization of uncertainties
*     -- bug fixed (NEW_ROUTINE was never called)
*     -- new combination routines: CHI2_SYM and CHI2_SYM_INDEP
*     Version 1.20, December 13, 1996:
*     -- new definition of a correlated systematic contribution, now including
*        all contributions associated with a parameter, even if they appear 
*        only in one of the analyses to be combined
*     -- fix bug (EXCUP and EXCUN were filled with excursions, not the 
*                 absolute value of the excursions, like said in master.inc)
*     -- systematic contribution not associated to a parameter at the input 
*         level, are associated to a "parameter" in file master.inc with a
*         value of 0 and excursion of +-1
*     -- perform symmetrization of parameter excursion
*     Version 1.21, January 17, 1997:
*     -- bug fixed (NPARA and NCSYS could go out of range; now protected)
*     Version 1.30, January 27, 1997:
*     -- handle synonyms (array KSYN)
*     Version 1.40, February 6, 1997:
*     -- bug fixed in synonym handling: KSYN(KPAR(...)) replaced with KPAR(...)
*         since two parameter names cannot be synonymed and since the synonym
*         name is the parameter name when a non-parameter name is synonymed 
*         with a parameter name
*     -- bug fixed in handling of correlation "ignoration";
*         when XNOCO_SYST was .TRUE. the correlations among contributions
*         associated to parameters were not ignored (but the other ones were)
*     -- protect against overflow in string CH80
*     -- handle lumps (array KLUMP)
*     Version 1.50, February 12, 1997:
*     -- new step synchronization procedure: if no desired steps are specified 
*        as input arguments to routine MASTER, then the step synchronization is
*        unchanged compared to previous versions; if desired steps are 
*        specified, then linear interpolation occurs between the steps of the
*        individual analyses, as needed (extrapolation is not allowed)
*     -- new routine DUMP_MASTER_INC to dump the content of master.inc; the 
*        dump is triggered by the presence of a parameter DUMP_MASTER_INC and 
*        the parameter value is the logical unit for the dump
*     Version 2.00, February 20, 1997:
*     -- bug fixed in handling of lumps in the case that systematic
*         correlations are switched off
*     -- new option implemented to switch off lumps
*     -- store new variables (CHROUT, CHSTEP, ISTEP, VSTEP, LUNIT) in master.inc
*     -- no step synchronization performed if argument NS is zero on input; 
*         the only "step processing" done by this routine is to ignore the 
*         steps for which interpolation (or extrapolation) is needed but not
*         allowed; the determination of default step values in case no steps 
*         are explicitely specified by the user is not done in MASTER anymore,
*         but in CHECK_STEPS
*     -- parameter DUMP_MASTER_INC is not used anymore; routine DUMP_MASTER_INC
*         turned into a combination routine; to trigger the dump, specify
*         routine DUMP_MASTER_INC on a CALL logical line
*     -- dimension of argument RESULT increased from (MSTEP,-1:1) to 
*         (MSTEP,-MR:MR) to allow space for the statistical and systematic
*         uncertainties on the combined results, in addition to the total 
*         uncertainty
*     -- implemented a way of determining the statistical uncertainties on the
*         combined results; each combination routine is called twice: first
*         in a condition where the systematic uncertainties are ignored, and
*         then in a condition where the systematic uncertainties are included; 
*         the statistical uncertainties are determined by the first calls; 
*         the total uncertainties by the second calls, and the systematic 
*         uncertainties are obtained by quadratic subtraction
*     -- new option implemented to switch off the evaluation of the statistical 
*         and systematic uncertainties on the combined results
*     -- improved printout of the combined results (symmetric errors,
*         confidence levels not available, error codes generated by the 
*         combination routines)
*     -- added the possibility of calling terminations routines:
*         each termination routine is called for each combination routine, 
*         but only once for all steps, after the combined results have been 
*         obtained; the combined results from all steps are made available to
*         the termination routine
*     Version 2.10, February 27, 1997:
*     -- SAVE arguments to routine COMBINE (to get reliable results on HP-UX)
*     -- new argument in calls to routine ANALYSIS_NAME
*     -- the content of variable CHCOMB has changed slightly (the combined
*        analysis name is no longer prefixed with "combined analysis ")
*     -- fill new array of variables CHANAL in in master.inc with the names of
*        the individual analyses in the combination
*     -- internal rewriting (new dimension to array ISYNCH)
*     -- new EXTRAPOLATION switch (parameter LEXTR)
*     -- handling of step extrapolation: if extrapolation between two step
*        values is needed in an individual analysis included in the combination,
*        then extrapolation occurs only if switch EXTRAPOLATION is ON; 
*        otherwise, the analysis is ignored in the combination (only for that
*        combined step) by setting its statsitical uncertainty to a very large
*        positive value
*     -- improved printout (step extrapolation and ignored measurements)
*     -- new termination routines KUMAC_NOSTEP and KUMAC_DMS_LIMIT
*     Version 2.12, March 8, 1997:
*     -- protect square root in calculation of total systematic uncertainty
*        on combined result
*     -- fix major bug in adjustment procedure; the central values were always
*        ajusted with the positive systematic uncertainty, i.e. the quantity
*        sigma^+ was used instead of sigma^- in Equation 1 of the COMBOS
*        user guide !
*     Version 2.13, March 10, 1997:
*     -- implement a better fix of major bug fixed in version 2.12 (this new 
*        fix is in principle equivalent, but more "robust" than the one
*        implemented in version 2.12)
*     Version 2.14, March 19, 1997:
*     -- bug fixed (dimension of USAVE was too small and leading to overwriting)
*     Version 2.20, April 3, 1997:
*     -- new combination routine CHI2_SYM_CIRC_G
*     Version 2.30, May 12, 1997:
*     -- bug fixed in printout of step extrapolation
*     -- SYMMETRIZATION switch renamed SYMM_COMB (parameter LSYMM renamed LSYMC)
*        note that this switch only symmetrizes the input to the combination 
*        routines (but it does no enable symmetric adjustements)
*     -- switch SYMM_COMB will now also symmetrize the parameter excursions
*        in addition to the uncertainties
*     -- print message if SYMM_COMB switch is on
*     -- new SYMM_ADJU switch (parameter LSYMA); this switch allows to perform
*        symmetric adjustements before the combination routines are called; 
*        it has no effect if the ADJUSTEMENTS switch is OFF
*     -- re-write code to printout parameters (should be equivalent)
*     -- call routine WRITE_KUMAC to write kumac file
*     -- termination routine KUMAC_NOSTEP removed
*     -- new combination routine BLUE
*     -- change value INFINITY parameter from 1.73205D+19 to 1.73205D+19/MMEAS
*     -- fill new variable NMEFF (NMEFF = number of "effective" measurements = 
*        number of measurements which have not been de-weighted by COMBOS)
*     -- new combination routine SINGLE
*     Version 2.31, Jun 19, 1997:
*     -- increase size of strings CH80 and CH80_BIS from 80 to 120 characters
*        (this is needed to cope with cases where more than 20 analyses are
*        combined)
*     -- fix format of the printout of the list of systematics to allow up 
*        to 30 analyses in the combination
*     Version 2.40, October 14, 1997:
*     -- Insert new routine CHI2_ASYM_MIN (HCJS)
*     -- Change routine SLAVE so it knows if systematics being 
*        ignored or not; needed for MINOS errors (HCJS)
*     Version 2.52, July 12, 1999:
*     -- new termination routine FINAL_FRACTIONS
*     -- introduction of the concept of preparation routines; 
*        new preparation routines ADJUST_SIGASTAT and NEW_PREPARATION
*     Version 2.53, November 27, 1999:
*     -- preparation routine ADJUST_SIGASTAT renamed to ADJU_A_FOR_FBS
*     Version 2.98, September 7, 1999:
*     -- new preparation routine USER_DMS_SENS
*     Version 3.00, January 29, 2002:
*     -- size of CH80 increased from 1230 to 160
*     Version 3.10, January 21, 2003:
*     -- changed FORMAT statements for Vcb (E. Barberio)
*     Version 3.22, February 10, 2003:
*     -- call CHI2_SYM instead of CHI2_SYM_CIRC_G or CHI2_SYM_CIRC to get 
*        "stat only" result
*     Version 3.32, January 20, 2010 (OS)
*     -- new printout format for the results of the combination routines
*        allowing for NQUAN=2 (in new subroutine PRINT_QUAN)
*
************************************************************************
*
      SUBROUTINE MASTER(N,ICOMB,NS,RESTEP,RESULT,IERR)
*     ================================================
*
*     Master routine to drive the combination of N analyses
*
*     This routine will, from the data found in combos.inc, fill the 
*     common block in master.inc.
*
*     Input:  N      = number of analyses to combine
*     -----   ICOMB  = array of indexes to analyses
*                      ICOMB(I) = analysis number of Ith analysis to combine
*             NS     = number of requested steps
*             RESTEP = array of values of step variable
*                      RESTEP(IS) = value of step variable for step IS (IS=1,NS)
*       
*     Output: NS     = number of steps for the combination
*     ------- RESTEP = array of values of step variable
*                      RESTEP(IS) = value of step variable for step IS (IS=1,NS)
*             RESULT = array of results
*                      RESULT(IS, 0) = central value for step IS
*                      RESULT(IS,+I) = positive uncertainty on RESULT(IS, 0)
*                      RESULT(IS,-I) = negative uncertainty on RESULT(IS, 0)
*                        for I=1,3:   I=1 statistical uncertainty
*                                     I=2 systematic  uncertainty
*                                     I=3 total       uncertainty
*             IERR   = error flag (0 means OK)
*
      IMPLICIT NONE
      INCLUDE 'combos.inc' ! input
      INCLUDE 'master.inc' ! output

*
*     Arguments
*
      INTEGER N 
      INTEGER ICOMB(N)
      INTEGER NS,MR
      PARAMETER(MR=FCONT-1)
      REAL RESTEP(MSTEP),RESULT(MSTEP,-MR:+MR)
      INTEGER IERR
*
*     Externals
*
      INTEGER LENOCC,LVMINA
      REAL VMIN,VMAX
*
*     Local variables
*
      REAL DUMMY
      LOGICAL DRPRINT
      DATA DRPRINT/.FALSE./
      DOUBLE PRECISION RHO
      INTEGER NRHO,NCORLIST,CORLIST(MMEAS)
      INTEGER I,IANAL,ICONT,J,JANAL,JCONT,IPAR,JPAR,INTER
*OSOS start
*OSOS INTEGER K,ISTEP1,ISTEP2,IS,JS,IC,KST,KCO,ILINK,NLINKS
      INTEGER K,ISTEP1,ISTEP2,IS,JS,IC,KST,ILINK,NLINKS
*OSOS end
      CHARACTER*16 UNDERLINE
      DATA UNDERLINE/'----------------'/
      CHARACTER*160 CH80,CH80_BIS
      INTEGER KCORR(MCONT,MANAL)
      INTEGER KCSYS(MCONT),ICSYS
      INTEGER ISYNCH(2,MANAL,0:MSTEP)
      REAL    DSYNCH(MANAL,MSTEP)
      REAL ST(MANAL),DSTEP(MSTEP),F1,F2,CONSTEP(-2*MCONT:2*MCONT)
      INTEGER NDIFF,NADJUST
      REAL TEMP(-1:1),ADJUST(-1:1,MCONT,MANAL)
      REAL ALPHA(-1:1),SIGMA(-1:1)
      DOUBLE PRECISION DALPHA,DSIGMA,AMEAS(MMEAS,MCONT)
      INTEGER CPAR(2,MCONT,MANAL)
      INTEGER IO(3)
      DATA IO/0,+1,-1/
      CHARACTER*16 CH16(-1:1)
      DATA CH16/'    pos. excurs.',' ','    neg. excurs.'/
      LOGICAL INTERPOLATE,FIRST_IN_LUMP,NEED_EXTRA
      INTEGER MSAVE
      PARAMETER(MSAVE=3+MQUAN)
      DOUBLE PRECISION USAVE(MMEAS,MSAVE)
      DOUBLE PRECISION INFINITY
      PARAMETER(INFINITY=1.73205D+19/MMEAS) ! = sqrt(3.e+38)/MMEAS
*      PARAMETER(INFINITY=1.73205D+19) ! = sqrt(3.e+38)
*      PARAMETER(INFINITY=DSQRT(3.3866D+38))
*     Note:  3.3866E+38 is the largest single precision number
*            that can be reprensented on OSF1, AIX and HP-UX
*DR 
      INTEGER IQUANUM(MNAM),IQUAN,IKCO(MQUANT)
*
*     Variables to store all the results
*
      INTEGER MCASE,NCASE
      PARAMETER(MCASE=2)
*OSOS start
      DOUBLE PRECISION CSTEP(MSTEP),CVAL (MSTEP,MCASE,MCALLC),
     &    ERR2P(MSTEP,MCASE,MCALLC),ERR2N(MSTEP,MCASE,MCALLC),
     &    ERR2 (MSTEP,MCASE,MCALLC),CL   (MSTEP,MCASE,MCALLC)
     & ,ES,EU,EC(MCSYS)
      INTEGER         CERR(0:MSTEP,MCASE,MCALLC)
      SAVE CVAL,ERR2P,ERR2N,ERR2,CL,CERR ! seems to be needed on HP-UX
*OSOS end

*DR add other dim for the quantities to be fitted
*OSOS DOUBLE PRECISION CSTEP(MSTEP),CVAL(MQUAN,MCASE,MSTEP,MCALLC),
*OSOS&                ERR2P(MQUAN,MQUAN,MCASE,MSTEP,MCALLC),
*OSOS&                ERR2N(MQUAN,MQUAN,MCASE,MSTEP,MCALLC),
*OSOS&                ERR2 (MQUAN,MQUAN,MCASE,MSTEP,MCALLC),
*OSOS&                CL   (MCASE,MSTEP,MCALLC)
*OSOS INTEGER         CERR (MCASE,0:MSTEP,MCALLC)
*OSOS SAVE CVAL,ERR2P,ERR2N,ERR2,CL,CERR ! seems to be needed on HP-UX
*
      IERR=0

*RVK clear scaling variables
      call vzero(xsstat,MMEAS*2)
      call vzero(xsusys,MMEAS*2)
      call vzero(xscsys,MMEAS*MCSYS*2)

*DR KCO disappear and is now replaced by IKCO()
*      KCO=KSYN(KCONT(0,NANAL))
*DR only work if only one quantity (will be updated if more than one)
*OSOS CHMEAS=CHNAM(KSYN(KCONT(0,NANAL)))

*DR see if we are combining one or several parameter
      IF (NQUANT.EQ.0) THEN
        CALL COMBOS_ERROR(-1,
     & 'No quantities to be fitted','cannot do anything')
      ELSEIF (NQUANT.EQ.2) THEN
        CALL COMBOS_ERROR(0,
     & 'Two quantities to be fitted',
     & 'it should work but are you sure it is what you want to do?')
      ELSEIF (NQUANT.GT.2) THEN
        CALL COMBOS_ERROR(0,
     & 'More than two quantities to be fitted',
     & 'it should work but are you sure it is what you want to do?')
C    & 'Never tested!') ! SwB, Jan 2010 :: Tested!!
      ENDIF
      NQUAN=NQUANT

      DO I=1,MNAM
        IQUANUM(I)=-1
      ENDDO
      DO IQUAN=1,NQUAN
        IKCO(IQUAN)=KSYN(KCONT(1-IQUAN,NANAL))
        IQUANUM(IKCO(IQUAN))=IQUAN
        CHQUAN(IQUAN)=CHNAM(IKCO(IQUAN))
      ENDDO

      DO I=1,N
        IANAL=ICOMB(I)
        KQUAN(I)=IQUANUM(KSYN(KCONT(0,IANAL)))
        IF (KQUAN(I).LT.0) THEN
          CALL COMBOS_ERROR(-1,'KQUAN<0','Inconsistencies!')
        ENDIF
      ENDDO  
    
      CHMEAS=' ' 
      DO IQUAN=NQUAN,1,-1
*OSOS   CHMEAS=CHMEAS(:LENOCC(CHMEAS))//' '//
*OSOS&           CHQUAN(IQUAN)(:LENOCC(CHQUAN(IQUAN)))
        CHMEAS=CHQUAN(IQUAN)(:LENOCC(CHQUAN(IQUAN)))//' '//CHMEAS
      ENDDO

*DR end
   

      IF(.NOT.XON(LQUST)) THEN
        KCONT(1,NANAL)=-IABS(KCONT(1,NANAL)) ! won't return stat error
        KCONT(2,NANAL)=-IABS(KCONT(2,NANAL)) ! won't return syst error
      ENDIF
      KST=KSYN(KSTEP(NANAL))
*
*     Store names of individual analyses, combined analysis,
*     measured quantity and step variable in master.inc
*
      DO I=1,N
        CALL ANALYSIS_NAME(.FALSE.,ICOMB(I),CHANAL(I))
      ENDDO
      CALL ANALYSIS_NAME(.FALSE.,NANAL,CHCOMB)

*DR      CHMEAS=CHNAM(KSYN(KCONT(0,NANAL)))

      IF(KST.EQ.0) THEN 
        CHSTEP=' '
      ELSE
        CHSTEP=CHNAM(KST)
      ENDIF
*
*     Store number of analyses to combine in master.inc
*
      NMEAS=N
      IF(NMEAS.GT.MMEAS) CALL COMBOS_ERROR(-1,
     & 'Too many measurements','please increase parameter MMEAS')
      IF(NMEAS*4.GT.LEN(CH80)) CALL COMBOS_ERROR(-1,
     & 'Too many measurements',
     & 'please increase length of CH80 in master.f')
*
*     Find out step synchronization: fill variable NS and array ISYNCH & DSYNCH
*     
*     NS             = number of steps in the combination
*     ISYNCH(J,I,IS) = step numbers (J=1,2) in analysis ICOMB(I) (I=1,N)
*                      corresponding to combination step IS (IS=1,NS)
*     DSYNCH(I,IS)   = difference in step variable between combination step IS
*                      and step ISYNCH(1,I,IS) in analysis ICOMB(I)
*
      INTERPOLATE=.FALSE.
      JS=0
      DO IS=1,NS
        INTER=0
        JS=JS+1
        DO I=1,N
          IANAL=ICOMB(I)
          DO J=1,NSTEP(IANAL)
            DSTEP(J)=RESTEP(IS)-STEP(J,IANAL)
          ENDDO
          ISYNCH(1,I,JS)=LVMINA(DSTEP,NSTEP(IANAL))
          DSYNCH(I,JS)=DSTEP(ISYNCH(1,I,JS))
          IF(DSYNCH(I,JS).NE.0) THEN 
            INTER=INTER+1
            ISYNCH(2,I,JS)=ISYNCH(1,I,IS)+NINT(SIGN(1.,DSYNCH(I,IS)))
          ELSE
            ISYNCH(2,I,JS)=ISYNCH(1,I,IS)
          ENDIF
          IF(ISYNCH(2,I,JS).GT.NSTEP(IANAL))
     &     ISYNCH(2,I,JS)=MAX0(ISYNCH(1,I,JS)-1,1)
          IF(ISYNCH(2,I,JS).LE.0)
     &     ISYNCH(2,I,JS)=MIN0(ISYNCH(1,I,JS)+1,NSTEP(IANAL))
        ENDDO
        IF(INTER.GT.0) THEN 
           IF(XON(LINTE)) THEN    
             INTERPOLATE=.TRUE.
           ELSE
              JS=JS-1
           ENDIF
        ENDIF
      ENDDO
      NS=JS
*
*     If LUMPS are switched off, reset array KLUMP
*
      IF(.NOT.XON(LLUMP)) THEN
        DO I=1,N
          IANAL=ICOMB(I)
          DO ICONT=0,NCONT(IANAL)
            KLUMP(ICONT,IANAL)=KCONT(ICONT,IANAL)
          ENDDO
        ENDDO
      ENDIF
*    
*     Find out which are the correlated systematics 
*     and which are the uncorrelated systematics.
*     Fill local array KCORR:
*                      KCORR(ICONT,IANAL) = 0 for uncorrelated systematics
*                      KCORR(ICONT,IANAL) = K for   correlated systematics
*     where K=1,NCSYS is the index for the arrays in common master.inc.
*     Store NCSYS in master.inc.
*     Store "systematic" parameters in master.inc (NPARA, and arrays PARA,
*     EXCUP, EXCUN, and CHPARA).
*
      NCSYS=0
      NPARA=NCSYS
      IF(XON(LSYST)) THEN ! don't ignore all systeamtics
        DO I=1,N
          IANAL=ICOMB(I)
          DO ICONT=FCONT,NCONT(IANAL)
            IF(KCONT(ICONT,IANAL).NE.KLUMP(ICONT,IANAL)) THEN
              KCORR(ICONT,IANAL)=1
            ELSE
              KCORR(ICONT,IANAL)=0
            ENDIF
            DO J=1,NPAR(IANAL) 
              IF(KPAR(J,IANAL).EQ.KSYN(KLUMP(ICONT,IANAL)))
     &         KCORR(ICONT,IANAL)=KCORR(ICONT,IANAL)+1
            ENDDO
            IF(XON(LCOSY)) THEN
              DO J=1,N
                IF(J.NE.I) THEN
                  JANAL=ICOMB(J)
                  DO JCONT=FCONT,NCONT(JANAL) 
                    IF(KSYN(KLUMP(JCONT,JANAL)).EQ.
     &                 KSYN(KLUMP(ICONT,IANAL)))
     &               KCORR(ICONT,IANAL)=KCORR(ICONT,IANAL)+1
                  ENDDO
                ENDIF
              ENDDO
            ENDIF
            IF(KCORR(ICONT,IANAL).NE.0) THEN ! correlated systematics
              KCORR(ICONT,IANAL)=0
              FIRST_IN_LUMP=.TRUE.
              DO JCONT=FCONT,ICONT-1
                FIRST_IN_LUMP=FIRST_IN_LUMP.AND.
     &           KSYN(KLUMP(JCONT,IANAL)).NE.KSYN(KLUMP(ICONT,IANAL))
              ENDDO
              IF(XON(LCOSY).OR..NOT.FIRST_IN_LUMP) THEN
                DO K=1,NCSYS
                  IF(KCSYS(K).EQ.KSYN(KLUMP(ICONT,IANAL)))
     &             KCORR(ICONT,IANAL)=K
                ENDDO
              ENDIF
              IF(KCORR(ICONT,IANAL).EQ.0) THEN
                IF(NCSYS.EQ.MCONT) THEN 
                  PRINT * ,'MASTER: serious problem !!!'
                  STOP 999
                ENDIF
                NCSYS=NCSYS+1
                IF(NCSYS.GT.MCSYS) CALL COMBOS_ERROR(-1,
     &            'Too many correlated systematics',
     &            'please increase parameter MCSYS')
                KCSYS(NCSYS)=KSYN(KLUMP(ICONT,IANAL))
                KCORR(ICONT,IANAL)=NCSYS
                NPARA=NCSYS
                IF(NPARA.GT.MPARA) CALL COMBOS_ERROR(-1,
     &            'Too many parameters',
     &            'please increase parameter MPARA')
                JPAR=0
                DO IPAR=1,NPAR(NANAL)
                  IF(KPAR(IPAR,NANAL).EQ.KCSYS(NCSYS)) JPAR=IPAR
                ENDDO
                IF(JPAR.EQ.0) THEN
                  PARA(NPARA)=0.D0
                  EXCUP(NPARA)=1.D0
                  EXCUN(NPARA)=1.D0
                  CHPARA(NPARA)=CHNAM(KCSYS(NCSYS))
                ELSE
                  PARA(NPARA)=DBLE(PAR(0,JPAR,NANAL))
                  EXCUP(NPARA)=DBLE(+PAR(+1,JPAR,NANAL))
                  EXCUN(NPARA)=DBLE(-PAR(-1,JPAR,NANAL))
                  CHPARA(NPARA)=CHNAM(KPAR(JPAR,NANAL))
                  IF(CHPARA(NPARA).NE.CHNAM(KCSYS(NCSYS))) THEN
                    PRINT * ,'MASTER: fatal problem: ',CHPARA(NPARA),
     &                         CHNAM(KCSYS(NCSYS))
                    STOP 4466
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDIF
*
*     Store "extra" parameters in master.inc 
*     (NPARA, PARA, EXCUP, EXCUN, CHPARA).
*
      DO 11 IPAR=1,NPAR(NANAL)
        DO I=1,NCSYS
          IF(KPAR(IPAR,NANAL).EQ.KCSYS(I)) GOTO 11
        ENDDO
        NPARA=NPARA+1
        IF(NPARA.GT.MPARA) CALL COMBOS_ERROR(-1,
     &    'Too many parameters','please increase parameter MPARA')
        PARA(NPARA)=DBLE(PAR(0,IPAR,NANAL))
        EXCUP(NPARA)=DBLE(+PAR(+1,IPAR,NANAL))
        EXCUN(NPARA)=DBLE(-PAR(-1,IPAR,NANAL))
        CHPARA(NPARA)=CHNAM(KPAR(IPAR,NANAL))
   11 ENDDO


*
*     Symmetrize parameter excursions
*
      DO I=1,NPARA
        CALL SYMMETRIZE(EXCUP(I),-EXCUN(I),EXCU(I))
        IF(XON(LSYMC)) THEN ! symmetrize
          EXCUP(I)=EXCU(I)
          EXCUN(I)=EXCU(I)
        ENDIF
      ENDDO
*
*     Find out if the parameter values are different
*     in the various analyses to combine.
*
      NADJUST=0
      DO I=1,N
        IANAL=ICOMB(I)
        DO ICONT=1,NCONT(IANAL)
          ADJUST( 0,ICONT,IANAL)=0.
          ADJUST(+1,ICONT,IANAL)=1.
          ADJUST(-1,ICONT,IANAL)=1.
          CPAR( 1,ICONT,IANAL)=0
          CPAR( 2,ICONT,IANAL)=0
        ENDDO
      ENDDO
      DO IPAR=1,NPAR(NANAL)
        DO I=1,N
          IANAL=ICOMB(I)
          DO JPAR=1,NPAR(IANAL)
            IF(KPAR(IPAR,NANAL).EQ.KPAR(JPAR,IANAL).
     &         AND.PCONT(JPAR,IANAL).GT.0) THEN
              NDIFF=0
              IF(XON(LADJU)) THEN ! adjustments are not ignored
                DO K=-1,1
                  TEMP(K)=PAR(K,IPAR,NANAL)-PAR(K,JPAR,IANAL)
                  IF(TEMP(K).NE.0.) NDIFF=NDIFF+1
                ENDDO
              ENDIF
              IF(NDIFF.NE.0) THEN ! determine if adjustment is possible
                DO K=-1,1,2
                  ALPHA(K)=PAR(K,JPAR,IANAL)
                ENDDO
                IF(XON(LSYMA)) THEN 
                  CALL SYMMETRIZE(DBLE(ALPHA(+1)),DBLE(ALPHA(-1)),
     &                            DALPHA)
                  DO K=-1,1,2
                    ALPHA(K)=FLOAT(K)*SNGL(DALPHA)
                  ENDDO
                ENDIF 
                DO K=-1,1,2
                  IF(ALPHA(K).EQ.0..AND.NDIFF.NE.0) THEN
                    NDIFF=0
                    CALL ANALYSIS_NAME(.TRUE.,IANAL,CH80)
                    CALL COMBOS_ERROR(1,
     &              'Excursion of parameter '//CHNAM(KPAR(JPAR,IANAL))
     &              (:LENOCC(CHNAM(KPAR(JPAR,IANAL))))//
     &              ' is zero in '//CH80(:LENOCC(CH80)),
     &              'requested adjustment not performed')
                  ENDIF
                ENDDO
              ENDIF
              IF(NDIFF.NE.0) THEN ! determine adjustment
                ICONT=PCONT(JPAR,IANAL)
                ADJUST(0,ICONT,IANAL)=TEMP(0)/
     &             ABS(ALPHA(NINT(SIGN(1.,TEMP(0)))))
                DO K=-1,1,2
                  ADJUST(K,ICONT,IANAL)=ALPHA(K)
                  ALPHA(K)=PAR(K,IPAR,NANAL)
                ENDDO
                IF(XON(LSYMA)) THEN 
                  CALL SYMMETRIZE(DBLE(ALPHA(+1)),DBLE(ALPHA(-1)),
     &                            DALPHA)
                  DO K=-1,1,2
                    ALPHA(K)=FLOAT(K)*SNGL(DALPHA)
                  ENDDO
                ENDIF 
                DO K=-1,1,2
                  ADJUST(K,ICONT,IANAL)=ALPHA(K)/ADJUST(K,ICONT,IANAL)
                ENDDO
                CPAR(1,ICONT,IANAL)=JPAR ! param. number in analysis to combine
                CPAR(2,ICONT,IANAL)=IPAR ! param. number in combined analysis
                NADJUST=NADJUST+1
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
*
*     Determine statistical correlations and
*     store statistical correlation matrix STACOR in master.inc
*
      CALL UZERO(STACOR,1,2*MMEAS*MMEAS) ! double precision
      DO I=1,NMEAS
        IANAL=ICOMB(I)
        IF(.NOT.XON(LCOST)) THEN ! ignore statistical correlations
          NLINKS=0
        ELSE
          NLINKS=NLINK(IANAL)
        ENDIF
        DO ILINK=0,NLINKS
          IF(ABS(RHOSTA(ILINK,IANAL)).LE.1.) THEN
            DO J=1,NMEAS
              JANAL=ICOMB(J)
              IF(LINK(0,JANAL).EQ.LINK(ILINK,IANAL))
     &         STACOR(I,J)=RHOSTA(ILINK,IANAL)
            ENDDO
          ENDIF
        ENDDO
      ENDDO
*
*     Symmetrize correlation matrix
*     and build list of analyses with statistical correlations
*
      NCORLIST=0
      DO I=1,NMEAS
        NRHO=0
        DO J=1,NMEAS
*OS          RHO=DMAX1(STACOR(I,J),STACOR(J,I))
          IF(DABS(STACOR(I,J)).GT.DABS(STACOR(J,I))) THEN
            RHO=STACOR(I,J)
          ELSE
            RHO=STACOR(J,I)
          ENDIF
          IF((STACOR(I,J).NE.RHO.AND.STACOR(I,J).NE.0.D0).OR.
     &       (STACOR(J,I).NE.RHO.AND.STACOR(J,I).NE.0.D0)) THEN
            CALL ANALYSIS_NAME(.TRUE.,ICOMB(I),CH80)
            CALL ANALYSIS_NAME(.TRUE.,ICOMB(J),CH80_BIS)
            CALL COMBOS_ERROR(1,
     &      'Inconsistent correlation coefficients given between '//
     &      CH80(:LENOCC(CH80))//' and '//CH80_BIS(:LENOCC(CH80_BIS)),
     &      'strongest correlation coefficient used')
          ENDIF
          STACOR(I,J)=RHO
          STACOR(J,I)=RHO
          IF(RHO.NE.0.) NRHO=NRHO+1
        ENDDO
        IF(NRHO.GT.1) THEN
          NCORLIST=NCORLIST+1
          CORLIST(NCORLIST)=I
        ENDIF
      ENDDO



*
*     Printout: general information
*
      CALL ANALYSIS_NAME(.TRUE.,NANAL,CH80)
*DR add quantity to be fitted in printout
*      WRITE(LUNLOG,1000) CHNAM(KCO)(:LENOCC(CHNAM(KCO))),
*     &                   CH80(:LENOCC(CH80)),
*     &                   UNDERLINE(:LENOCC(CHNAM(KCO))),N
* 1000 FORMAT(/,1X,78('='),/,/,1X,
*     &       A,' combination: ',A,/,1X,
*     &       A,'-------------',/,/,1X,
*     &       'List of',I3,' analyses to combine:',/,/,
*     &       T02,'Analysis',T12,'Experiment',T28,'Method',
*     &       T44,'Quality ',T60,' N_steps')
 
      WRITE(LUNLOG,1000) CHMEAS(:LENOCC(CHMEAS)),
     &                   CH80(:LENOCC(CH80)),
*OSOS start
*OSOS&                   UNDERLINE(:LENOCC(CHNAM(KCO))),N
     &                   UNDERLINE(:LENOCC(CHMEAS)),N
*OSOS end
 1000 FORMAT(/,1X,78('='),/,/,1X,
     &       A,' combination: ',A,/,1X,
     &       A,'-------------',/,/,1X,
     &       'List of',I3,' analyses to combine:',/,/,
     &       T02,'Analysis',T12,'Experiment',T28,'Method',
*OSOS start
*OSOS&       T44,'Quality ',T60,' Quantity',T70,'N_steps')
     &       T44,'Quality ',T60,'Measurement',T76,'Steps')
*OSOS end
*DR end
      DO I=1,N
        IANAL=ICOMB(I)
*DR        WRITE(LUNLOG,1001) IANAL,
*     &                     CHEXP(KEXP(IANAL)),CHMETH(KMETH(IANAL)),
*     &                     CHSTAT(KSTAT(IANAL)),NSTEP(IANAL)
* 1001   FORMAT(T2,I7,'>',T12,A,T28,A,T44,A,T60,I8)
        WRITE(LUNLOG,1001) IANAL,
     &                     CHEXP(KEXP(IANAL)),CHMETH(KMETH(IANAL)),
     &          CHSTAT(KSTAT(IANAL)),
*OSOS start
*OSOS$          CHQUAN(KQUAN(IANAL)),
     &          CHQUAN(KQUAN(I)),
*OSOS end
     &          NSTEP(IANAL)
*OSOS start
*OSOS 1001   FORMAT(T2,I7,'>',T12,A,T28,A,T44,A,T60,A,T70,I8)
 1001   FORMAT(T2,I7,'>',T12,A,T28,A,T44,A,T60,A,T76,I8)
*OSOS end
      ENDDO
*DR      WRITE(LUNLOG,1002) CHEXP(KEXP(NANAL)),CHMETH(KMETH(NANAL)),
*     &                   CHSTAT(KSTAT(NANAL)),NS
* 1002 FORMAT(T2,'Combined',T12,A,T28,A,T44,A,T60,I8)
      WRITE(LUNLOG,1002) CHEXP(KEXP(NANAL)),CHMETH(KMETH(NANAL)),
     &                   CHSTAT(KSTAT(NANAL)),CHMEAS,NS
*OSOS start
*OSOS 1002 FORMAT(T2,'Combined',T12,A,T28,A,T44,A,T60,A,T70,I8)
 1002 FORMAT(T2,'Combined',T12,A,T28,A,T44,A,T60,A,T76,I8)
*OSOS end
*DR end*
*     Printout: step interpolation
*
      IF(INTERPOLATE) THEN
        WRITE(LUNLOG,1050) CHSTEP(:LENOCC(CHSTEP)),CHSTEP,
     &                     (ICOMB(I),I=1,N)
 1050   FORMAT(/,T7,'Desired',T18,'Difference between desired ',A,
     &         ' and closest step in the analyses',
     &         /,1X,'Step',T7,A10,T18,20(I7,1X))
        IF(XON(LEXTR)) THEN 
          CH16(0)='x' !--> extrapolate measurement if extrapolation needed
          CH80_BIS='extrapolation will be performed'
        ELSE
          CH16(0)='i' !--> ignore measurement if extrapolation needed
          WRITE(CH80_BIS,1049) INFINITY
 1049     FORMAT('measurement will be ignored (stat. error set to ',
     &           G10.4,')')
        ENDIF
        K=0
        DO IS=1,NS
          CH80=' '
          DO I=1,N
            IANAL=ICOMB(I)
            NEED_EXTRA=
     &           (DSYNCH(I,IS).LT.0..AND.ISYNCH(1,I,IS).EQ.1).OR.
     &           (DSYNCH(I,IS).GT.0..AND.ISYNCH(1,I,IS).EQ.NSTEP(IANAL))
            IF(NEED_EXTRA) THEN ! extrapolation needed
              CH80(I:I)=CH16(0)
              K=K+1
            ENDIF
          ENDDO
          WRITE(LUNLOG,1051) IS,
     &     STEP(ISYNCH(1,1,IS),ICOMB(1))+DSYNCH(1,IS),
     &     (DSYNCH(I,IS),CH80(I:I),I=1,N)
 1051     FORMAT(1X,I4,T7,F8.3,T18,20(F7.2,A1))
        ENDDO
        IF(K.GT.0)
     &   WRITE(LUNLOG,1052) CH16(0)(1:1),CH80_BIS(:LENOCC(CH80_BIS))
 1052   FORMAT(1X,'Note: "',A1,
     &   '" after step difference value means that ',A)
      ELSE IF(CHSTEP.NE.' ') THEN
        WRITE(LUNLOG,1053) CHSTEP(:LENOCC(CHSTEP))
 1053   FORMAT(/,1X,'No interpolation (or extrapolation) between ',
     &         A,' steps.')
      ENDIF
*
*     Printout: shifts of measurements
*
      IF(NADJUST.GT.0) THEN
        IF(XON(LSYMA)) THEN 
          WRITE(LUNLOG,1100) '"Symmetric" adjustments'
        ELSE
          WRITE(LUNLOG,1100) 'Adjustments'
        ENDIF
      ENDIF
 1100 FORMAT(/,1X,A,' performed to express the individual measurements',
     &       /,1X,'at the desired values of the parameters:',/,/,
     &       T02,'Analysis',T12,'Parameter',T28,'    Value used',
     &       T44,' Desired value',T60,'    Adjustment')
      DO I=1,N
        IANAL=ICOMB(I)
        DO ICONT=FCONT,NCONT(IANAL)
          JPAR=CPAR(1,ICONT,IANAL)
          IF(JPAR.NE.0) THEN
            IPAR=CPAR(2,ICONT,IANAL)
            CH16(0)=CHNAM(KPAR(JPAR,IANAL))
            WRITE(LUNLOG,1101) IANAL,(CH16(IO(K)),PAR(IO(K),JPAR,IANAL),
     &       PAR(IO(K),IPAR,NANAL),ADJUST(IO(K),ICONT,IANAL),K=1,3)
          ENDIF
        ENDDO
      ENDDO
 1101 FORMAT(T2,I7,'>',T12,A,T28,F14.4,T44,F14.4,T60,SP,F14.4,
     &           /,(SP,T12,A,T28,F14.4,T44,F14.4,T60,SS,F14.4))
*
*     Printout: symmetrization of uncertainties and parameter excursions
*
      IF(XON(LSYMC)) THEN 
        WRITE(LUNLOG,1198)
 1198   FORMAT(/,' All uncertainties and parameter excursions',
     &           ' will be symmetrized',
     &         /,' before calling the combination routines')
        IF(.NOT.XON(LSYMA)) WRITE(LUNLOG,1199)
 1199   FORMAT(  ' WARNING: ajustements are done using',
     &           ' unsymmetrized uncertainties and excursions')
      ENDIF
*
*     Printout: statistical correlations
*
      IF(NCORLIST.GT.0) 
     & WRITE(LUNLOG,1210) (ICOMB(CORLIST(I)),I=1,NCORLIST)
 1210 FORMAT(/,1X,
     & 'Statistical correlations:',
     & /,/,T02,'Analysis number',T21,20I6)
      DO I=1,NCORLIST
        WRITE(LUNLOG,1211) ICOMB(CORLIST(I)),
     &   (STACOR(CORLIST(I),CORLIST(J)),J=1,NCORLIST)
 1211   FORMAT(T02,I15,T21,20F6.3)
      ENDDO
*
*     Printout: correlated and uncorrelated systematics
*
      IF(XON(LSYST)) THEN ! don't ignore systematics
        WRITE(LUNLOG,1200) (ICOMB(I),I=1,N)
 1200   FORMAT(/,1X,
     &   'CORrelated and UNCorrelated systematic uncertainties:',
     &   /,/,T21,'Analysis number',/,T02,'Uncertainty',T21,30I4)
        DO IC=1,NCSYS
          CH80=' '
          DO I=1,N
            IANAL=ICOMB(I)
            DO ICONT=FCONT,NCONT(IANAL)
              IF(KCORR(ICONT,IANAL).EQ.IC) CH80(4*I-3:4*I)=' COR'
            ENDDO
          ENDDO
          WRITE(LUNLOG,1201) CHNAM(KCSYS(IC)),CH80(:LENOCC(CH80))
 1201     FORMAT(T02,A,T21,A)
          DO J=1,NNAM
            IF(J.NE.KCSYS(IC).AND.KSYN(J).EQ.KCSYS(IC))
     &       WRITE(LUNLOG,1202) CHNAM(J)
 1202        FORMAT(T02,'= ',A,I3)
          ENDDO
          IF(CHNAM(KCSYS(IC))(:5).EQ.'lump ') THEN
            DO I=1,N
              IANAL=ICOMB(I)
              CH80=' '
              DO ICONT=FCONT,NCONT(IANAL)
                IF(KSYN(KLUMP(ICONT,IANAL)).EQ.KCSYS(IC)) THEN
                  IF(CH80.EQ.' ') THEN 
                    CH80='('//CHNAM(KCONT(ICONT,IANAL))
                  ELSE IF(LENOCC(CH80)+3+
     &                    LENOCC(CHNAM(KCONT(ICONT,IANAL)))
     &                    .LE.LEN(CH80)) THEN
                    CH80=CH80(:LENOCC(CH80))//' & '//
     &                   CHNAM(KCONT(ICONT,IANAL))
                  ELSE
                    CH80=CH80(:LENOCC(CH80))//' & ...'
                    IF(CH80(LEN(CH80)-2:).NE.'   ') 
     &               CH80(LEN(CH80)-2:)='...'
                  ENDIF
                ENDIF
              ENDDO
              IF(CH80.NE.' ') WRITE(LUNLOG,1202) CH80(:LENOCC(CH80))//
     &                                           ') for analysis',IANAL
            ENDDO
          ENDIF
        ENDDO
        DO I=1,N
          IANAL=ICOMB(I)
          DO ICONT=FCONT,NCONT(IANAL)
            IF(KCORR(ICONT,IANAL).EQ.0) THEN 
              CH80=' '
              CH80(4*I-3:4*I)=' UNC'
              WRITE(LUNLOG,1201) CHNAM(KSYN(KCONT(ICONT,IANAL))),
     &                          CH80(:LENOCC(CH80))
              DO J=1,NNAM
                IF(J.NE.KSYN(KCONT(ICONT,IANAL)).AND.
     &             KSYN(J).EQ.KSYN(KCONT(ICONT,IANAL)))
     &           WRITE(LUNLOG,1202) CHNAM(J)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDIF
*
*     Printout: parameters of combined analysis
*
      DO I=1,NPARA
        IF(I.EQ.1.AND.I.LE.NCSYS) WRITE(LUNLOG,1300) 'Correlated'
        IF(I.EQ.NCSYS+1)          WRITE(LUNLOG,1300) 'Extra'
        WRITE(LUNLOG,1301) CHPARA(I),PARA(I),+EXCUP(I),-EXCUN(I),EXCU(I)
        DO J=1,NNAM
          IF(CHNAM(J).NE.CHPARA(I).AND.CHNAM(KSYN(J)).EQ.CHPARA(I))
     &     WRITE(LUNLOG,1202) CHNAM(J)
        ENDDO
      ENDDO
 1300 FORMAT(/, 1X,'"',A,'" parameters:')
 1301 FORMAT(1X,A,F10.4,SP,2F10.4,SS,F10.4)
*
*     Loop on steps
*
      DO IS=1,NS
*
*       Store MEAS, STATP, STATN, USYSP, USYSN, CSYSP, CSYSN in master.inc.
*
        NMEFF=NMEAS ! number of "effective" measurements, i.e. number of 
*                   ! measurements which have not been de-weighted
        DO I=1,N
          IANAL=ICOMB(I)
          ST(I)=STEP(ISYNCH(1,I,IS),IANAL)+DSYNCH(I,IS)
          IF(ST(I).NE.ST(1)) THEN 
            PRINT * ,'MASTER: serious inconsistency !!'
            STOP 991
          ENDIF
*
*         Interpolate between individual analysis steps
*
*         x = x1 * f1 + x2 * f2
*
*         where f1 = (s2-s)/(s2-s1) 
*               f2 = (s1-s)/(s1-s2)
*
*         s = step variable
*         x = quantity to interpolate (or extrapolate)
*
          ISTEP1=ISYNCH(1,I,IS)
          ISTEP2=ISYNCH(2,I,IS)
          NEED_EXTRA=(DSYNCH(I,IS).LT.0..AND.ISTEP1.EQ.1).OR.
     &               (DSYNCH(I,IS).GT.0..AND.ISTEP1.EQ.NSTEP(IANAL))
*                    ! extrapolation needed ?
          IF(NEED_EXTRA.AND..NOT.XON(LEXTR)) ISTEP1=ISTEP2
          IF(ISTEP1.EQ.ISTEP2) THEN
            F1=0.5
            F2=0.5
          ELSE
            F1=(STEP(ISTEP2,IANAL)-ST(I))/
     &         (STEP(ISTEP2,IANAL)-STEP(ISTEP1,IANAL))
            F2=(STEP(ISTEP1,IANAL)-ST(I))/
     &         (STEP(ISTEP1,IANAL)-STEP(ISTEP2,IANAL))
          ENDIF
          DO K=-NCONT(IANAL),NCONT(IANAL)
            CONSTEP(K)=CONT(ISTEP1,K,IANAL)*F1+CONT(ISTEP2,K,IANAL)*F2
crvk - this is where the cont array gets used...
            CONSTEP(SIGN(1,K)*MCONT+K)=
     &         CONT(ISTEP1,SIGN(1,K)*MCONT+K,IANAL)
          ENDDO
*
          MEAS (I)=DBLE(CONSTEP(0))
          IF(NEED_EXTRA.AND..NOT.XON(LEXTR)) THEN
            STATP(I)=INFINITY ! effectively remove measurement from combination
            STATN(I)=INFINITY ! by setting the statistical error to "infinity"
            NMEFF=NMEFF-1 ! ... because one more measurement was de-weighted
          ELSE
            STATP(I)=DBLE(ABS(CONSTEP(+1)))
            STATN(I)=DBLE(ABS(CONSTEP(-1)))
          ENDIF
          USYSP(I)=0.D0
          USYSN(I)=0.D0
          DO IC=1,NCSYS
            CSYSP(I,IC)=0.D0
            CSYSN(I,IC)=0.D0
          ENDDO
*
*         Printout of measurement before adjustments (format from DR)
*
          IF(DRPRINT) WRITE
     &   (LUNLOG,'(1X,''Analysis '',I3,'', Initial value '',F11.5)')
     &   I,MEAS(I)
crvk - fill xsstat array here
          XSSTAT(I) = CONSTEP(MCONT+1)
          DO ICONT=FCONT,NCONT(IANAL)
*
*           Adjust measurement to the desired value of the parameter;
*           fill array TEMP with uncertainties from contribution ICONT, 
*           rescaled for desired values of the parameter excursions.
*
            DO K=-1,1,2
              SIGMA(K)=CONSTEP(K*ICONT)
            ENDDO

            IF(XON(LSYMA)) THEN 
              CALL SYMMETRIZE(DBLE(SIGMA(+1)),DBLE(SIGMA(-1)),DSIGMA)
              DO K=-1,1,2
                SIGMA(K)=FLOAT(K)*SNGL(DSIGMA)
              ENDDO
            ENDIF 
            DO K=-1,+1
              IF(K.EQ.0) THEN
                TEMP(K)=0.
                AMEAS(I,ICONT)=DBLE(ABS(ADJUST(0,ICONT,IANAL))*
     &                  SIGMA(NINT(SIGN(1.,ADJUST(0,ICONT,IANAL)))))
                MEAS(I)=MEAS(I)+AMEAS(I,ICONT)
*DR
              ELSE
                TEMP(K)=SIGMA(K)*ADJUST(K,ICONT,IANAL)
              ENDIF
            ENDDO
*
*           Printout of adjustment (format from DR)
*
            IF(AMEAS(I,ICONT).NE.0..AND.DRPRINT) THEN
              CH80=CHNAM(KPAR(CPAR(1,ICONT,IANAL),ICOMB(I)))
              WRITE
     &  (LUNLOG,'(''...corr for par '',A,T25,F11.5,'' syst'',2F11.5)')
     & CH80(:LENOCC(CH80)),AMEAS(I,ICONT),TEMP(-1),TEMP(+1)   
            ENDIF  
*
            ICSYS=KCORR(ICONT,IANAL)
crvk - fill xsxsys arrays here
            IF(.NOT.XON(LSYST)) THEN ! ignore all systematics
            ELSE IF(ICSYS.EQ.0) THEN ! uncorrelated systematics
              USYSP(I)=USYSP(I)+DBLE(VMAX(TEMP,3))**2
              USYSN(I)=USYSN(I)+DBLE(VMIN(TEMP,3))**2
crvk - crude choice of which uncorrelated error to take the scaling from;
crvk - once you start scaling you shouldn't really lump errors.
               IF(0.25*USYSP(I).LT.DBLE(VMAX(TEMP,3))**2) THEN
                  XSUSYS(I) = CONSTEP(MCONT+ICONT)
               ENDIF
            ELSE IF(CHNAM(KCSYS(ICSYS))(:5).EQ.
     &              'lump ') THEN ! "lumped" correlated systematics
              CSYSP(I,ICSYS)=+DSQRT(
     &        CSYSP(I,ICSYS)**2+DBLE(VMAX(TEMP,3))**2)
              CSYSN(I,ICSYS)=-DSQRT(
     &        CSYSN(I,ICSYS)**2+DBLE(VMIN(TEMP,3))**2)
              IF(0.5*CSYSP(I,ICSYS).LT.DBLE(VMAX(TEMP,3))) THEN
                 XSCSYS(I,ICSYS) = CONSTEP(MCONT+ICONT)
              ENDIF
            ELSE ! "normal" correlated systematics
              CSYSP(I,ICSYS)=DBLE(TEMP(+1))
              CSYSP(I,ICSYS)=TEMP(+1)
              CSYSN(I,ICSYS)=DBLE(TEMP(-1))
              XSCSYS(I,ICSYS) = CONSTEP(MCONT+ICONT)
            ENDIF
          ENDDO
*
*         Printout of measurement after adjustment (format from DR)
*
          IF(DRPRINT) WRITE
     & (LUNLOG,'(''...-->Final Value:'',F11.5)') MEAS(I)
*
          USYSP(I)=DSQRT(USYSP(I))
          USYSN(I)=DSQRT(USYSN(I))
*
*         Compute symmetric uncertainties; fill STAT, USYS, and CSYS
*
          CALL SYMMETRIZE(STATP(I),-STATN(I),STAT(I))
          CALL SYMMETRIZE(USYSP(I),-USYSN(I),USYS(I))
          IF(XON(LSYMC)) THEN ! symmetrize uncertainties
            STATP(I)=STAT(I)
            STATN(I)=STAT(I)
            USYSP(I)=USYS(I)
            USYSN(I)=USYS(I)
          ENDIF
          DO IC=1,NCSYS
            CALL SYMMETRIZE(CSYSP(I,IC),CSYSN(I,IC),CSYS(I,IC))
            IF(XON(LSYMC)) THEN ! symmetrize uncertainties
              CSYSP(I,IC)=+CSYS(I,IC)
              CSYSN(I,IC)=-CSYS(I,IC)
            ENDIF
          ENDDO
        ENDDO


*
*       Store step number and value in master.inc
*
        ISTEP=IS
        VSTEP=DBLE(ST(1))
        CSTEP(IS)=VSTEP
*
*       At this point, all variables and array of master.inc are filled, 
*       except the name of the combination routine, CHROUT, and the logical 
*       unit for the printout of the combination routine, LUNIT (these two
*       variables are filled in routine COMBINE).
*
*       First call a preparation routine if requested
*
        DO I=1,NCALLP ! loop on preparation routines
          K=KCALLP(I)
          CHROUT=CHCALP(K) ! store name of preparation routine in master.inc
          LUNIT=LCALLP(I)  ! store logical unit for printout in master.inc
*zzz      IF(IS.NE.1) LUNIT=0 ! turn printout off unless this is the first step
          IF(CHCALP(K).EQ.'ADJU_A_FOR_FBS') THEN
            CALL ADJU_A_FOR_FBS(N,ICOMB,AMEAS)
          ELSE IF(CHCALP(K).EQ.'USER_DMS_SENS') THEN
            CALL USER_DMS_SENS(N,ICOMB)
          ELSE IF(CHCALP(K).EQ.'NEW_PREPARATION') THEN
            CALL NEW_PREPARATION(N,ICOMB)
          ELSE
            PRINT * ,'MASTER: routine ',CHCALP(K),' not available'
            STOP 6634
          ENDIF
        ENDDO
*
        IF(IS.EQ.1) THEN
          WRITE(LUNLOG,2222) 
 2222     FORMAT(/,1X,'Results of combination:',/)
          IF(CHSTEP.NE.' ') THEN
            CH16(0)=CHSTEP
            CALL CRIGHT(CH16(0),1,10)
            WRITE(LUNLOG,2000) CH16(0)(:10),
*OSOS start
*OSOS&                         CHNAM(KCO)(:LENOCC(CHNAM(KCO)))
     &                         CHMEAS(:LENOCC(CHMEAS))
*OSOS end
 2000       FORMAT(T2,'Step',T8,A,T20,'Routine',
     &        T36,'Combined ',A,' and its error',T74,' ',T75,'CL    ')
          ENDIF
        ENDIF
*
*       Then do the combination for that step, ignoring all systematics
*       (in order to get the statistical uncertainty on the combined value)
*
        IF(XON(LQUST)) THEN
*DR 4 -> 3+NQUAN
          CALL UCOPY(USYS,USAVE,2*(3+NQUAN)*MMEAS) ! save USYS, USYSP, USYSN, 
*                                            and first NQUAN 
*                                            rows of CSYS (because routine 
*                                            PREPARE_CHI2 will overwrite that
*                                            first NQUAN rows ...)
          CALL UZERO(USYS,    1,2*3*MMEAS) ! zero USYS, USYSP, USYSN 
*                                            (double precision !)
          K=NCSYS ! save NCSYS
          NCSYS=0 ! zero NCSYS
          CALL COMBINE(2,CVAL,ERR2P,ERR2N,ERR2,CL,CERR
     &   ,ES,EU,EC)
*DR 4->3+NQUAN
         CALL UCOPY(USAVE,USYS,2*(3+NQUAN)*MMEAS) ! restore USYS, USYSP, USYSN, 
*                                            and first NQUAN rows of CSYS
          NCSYS=K ! restore NCSYS
          NCASE=2
        ELSE
          NCASE=1
        ENDIF
*
*       Then do the "real" combination for that step
*
        CALL COMBINE(1,CVAL,ERR2P,ERR2N,ERR2,CL,CERR
     &   ,ES,EU,EC)
*
*       Save results of first combination routine and return them in arguments
*
        K=KCALLC(1) ! select first combination routine
        RESTEP(IS   )=ST(1)
        IF(XON(LQUST)) THEN
          RESULT(IS,+1)=+SNGL(DSQRT(ERR2P(IS,2,K)))
          RESULT(IS,-1)=-SNGL(DSQRT(ERR2N(IS,2,K)))
          IF(ERR2P(IS,1,K).GE.ERR2P(IS,2,K)) THEN
            RESULT(IS,+2)=+SNGL(DSQRT(ERR2P(IS,1,K)-ERR2P(IS,2,K)))
          ELSE
            RESULT(IS,+2)=-9999.D0
          ENDIF
          IF(ERR2N(IS,1,K).GE.ERR2N(IS,2,K)) THEN
            RESULT(IS,-2)=-SNGL(DSQRT(ERR2N(IS,1,K)-ERR2N(IS,2,K)))
          ELSE
            RESULT(IS,-2)=+9999.D0
          ENDIF
          IERR=CERR(0,2,K)
        ELSE
          RESULT(IS,+1)=0.
          RESULT(IS,-1)=0.
          RESULT(IS,+2)=0.
          RESULT(IS,-2)=0.
          IERR=0
        ENDIF
        RESULT(IS, 0)=SNGL(CVAL(IS,1,K))
        RESULT(IS,+3)=+SNGL(DSQRT(ERR2P(IS,1,K)))
        RESULT(IS,-3)=-SNGL(DSQRT(ERR2N(IS,1,K)))
        IERR=IERR+CERR(0,1,K)
*
*       Write KUMAC file (only in case NQUAN=1)
*
        IF(LUNKUM.GT.0.AND.NQUAN.EQ.1) THEN
          DO I=1,NCALLC ! loop on combination routines
            K=KCALLC(I)
            CHROUT=CHCALC(K) ! store name of combination routine in master.inc
            CALL WRITE_KUMAC(N,ICOMB,
     &                       MSTEP,NCASE,CVAL(IS,1,K), ERR2P(IS,1,K),
     &                                   ERR2N(IS,1,K),ERR2 (IS,1,K),
     &                                   CL   (IS,1,K),CERR (IS,1,K),NS)
          ENDDO
        ENDIF
      ENDDO
*
*     Now do the termination (only if NQUAN=1):
*     call each termination routine for each combination routine, unless
*     combination failed at each step
*
      WRITE(LUNLOG,'(1X)') 
      IF(NQUAN.NE.1) RETURN
      DO I=1,NCALLC ! loop on combination routines
        K=KCALLC(I)
        IF(CERR(0,1,K).LT.NS) THEN
          CHROUT=CHCALC(K) ! store name of combination routine in master.inc
          DO J=1,NCALLT ! loop on termination routines
            LUNIT=LCALLT(J) ! store logical unit for printout in master.inc
            IF(CHCALT(KCALLT(J)).EQ.'SET_DMS_LIMIT') THEN
              CALL SET_DMS_LIMIT(NS,NCASE,MSTEP,CSTEP,CVAL(1,1,K),
     &                           ERR2P(1,1,K),ERR2N(1,1,K),ERR2(1,1,K),
     &                           CL(1,1,K),CERR(0,1,K))
            ELSE IF(CHCALT(KCALLT(J)).EQ.'KUMAC_DMS_LIMIT') THEN
              CALL KUMAC_DMS_LIMIT(.TRUE.)
              CALL SET_DMS_LIMIT(NS,NCASE,MSTEP,CSTEP,CVAL(1,1,K),
     &                           ERR2P(1,1,K),ERR2N(1,1,K),ERR2(1,1,K),
     &                           CL(1,1,K),CERR(0,1,K))
              CALL KUMAC_DMS_LIMIT(.FALSE.)
            ELSE IF(CHCALT(KCALLT(J)).EQ.'AVG_AMPLITUDE') THEN
              CALL AVG_AMPLITUDE(NS,NCASE,MSTEP,CSTEP,CVAL(1,1,K),
     &                           ERR2P(1,1,K),ERR2N(1,1,K),ERR2(1,1,K),
     &                           CL(1,1,K),CERR(0,1,K))
            ELSE IF(CHCALT(KCALLT(J)).EQ.'FINAL_FRACTIONS') THEN
              CALL FINAL_FRACTIONS(NS,NCASE,MSTEP,CSTEP,CVAL(1,1,K),
     &                           ERR2P(1,1,K),ERR2N(1,1,K),ERR2(1,1,K),
     &                           CL(1,1,K),CERR(0,1,K))
            ELSE
              PRINT * ,'MASTER: routine ',CHCALT(KCALLT(J)),
     &                        ' not available'
              STOP 6633
            ENDIF
          ENDDO
          CALL SET_DMS_LIMIT_USER(.FALSE.,DUMMY)
        ENDIF
      ENDDO
      END
*
************************************************************************
*
      SUBROUTINE SYMMETRIZE(SIGPOS,SIGNEG,SIG)
*     ========================================
*
*     Symmetrize uncertainties SIGPOS and SIGNEG
*
      IMPLICIT NONE
*
*     Arguments
*
      DOUBLE PRECISION SIGPOS,SIGNEG,SIG
*
*     Local variables
*
      DOUBLE PRECISION SIG1,SIG2 
*
      SIG1=DMAX1(DMAX1(SIGPOS,SIGNEG),0.D0)
      SIG2=DMIN1(DMIN1(SIGPOS,SIGNEG),0.D0)
      SIG=DSQRT(0.5D0*(SIG1**2+SIG2**2))
***      SIG=0.5D0*(DABS(SIG1)+DABS(SIG2))
***      SIG=DMAX1(DABS(SIG1),DABS(SIG2))
      SIG=DSIGN(SIG,SIGPOS)
      END
*
************************************************************************
*
      SUBROUTINE COMBINE(ICASE,CVAL,ERR2P,ERR2N,ERR2,CL,CERR
     &   ,ES,EU,EC)
*     =======================================================
*
*     Perform combination
*
*     Input:   ICASE : 1 means systematic uncertainties are not ignored
*     ------           2 means systematic uncertainties are ignored
*
*     Output:  CVAL  = array of combined values
*     -------  ERR2P = array of error matrices (positive errors)
*              ERR2N = array of error matrices (negative errors)
*              ERR2  = array of error matrices (symmetric errors)
*              CL    = array of confidence levels
*              CERR  = array of error codes
*
      IMPLICIT NONE
      INCLUDE 'combos.inc'
      INCLUDE 'master.inc'
*
*     Arguments
*
      INTEGER MCASE
      PARAMETER(MCASE=2)
      INTEGER ICASE,CERR(0:MSTEP,MCASE,MCALLC)
      DOUBLE PRECISION CVAL(MSTEP,MCASE,MCALLC),
     &              ERR2P(MSTEP,MCASE,MCALLC),ERR2N(MSTEP,MCASE,MCALLC),
     &              ERR2 (MSTEP,MCASE,MCALLC),CL  (MSTEP,MCASE,MCALLC),
     & ES,EU,EC(MCSYS),AA,ETOT
*
*     Externals
*
      INTEGER LENOCC
*
*     Local variables
*
      INTEGER I,K,IS,ICAS2,IC,J,NW
      INTEGER MQUAN_CHECK
*
      IF(ICASE.LE.0.OR.ICASE.GT.MCASE) THEN 
        PRINT * ,'COMBINE: invalid argument ICASE = ',ICASE
        STOP 8765
      ENDIF
      IS=ISTEP ! step number
      MQUAN_CHECK=MQUAN
      IF(MQUAN_CHECK.NE.MQUANT) THEN
        CALL COMBOS_ERROR(-1,'MQUAN, MQUANT','Inconsistency')
      ELSE IF(NQUAN.NE.NQUANT) THEN
        CALL COMBOS_ERROR(-1,'NQUAN, NQUANT','Inconsistency')
      ELSE IF(IS.GT.1.AND.NQUANT.GT.1) THEN
        CALL COMBOS_ERROR(-1,'IS, NQUAN','Inconsistency')
      ELSE IF(NQUAN.GT.1) THEN
        NW=MQUANT
      ELSE
        NW=1
      ENDIF
      DO I=1,NCALLC
        K=KCALLC(I)
        CHROUT=CHCALC(K) ! store name of combination routine in master.inc
*FP     write(*,*)CHROUT
        IF(ICASE.EQ.1) THEN
          LUNIT=LCALLC(I) ! store logical unit for printout in master.inc
        ELSE
          LUNIT=-IABS(LCALLC(I)) ! switch off printout of combination routine
        ENDIF
        CALL SLAVE(CHROUT,ICASE,NW,NQUAN,CVAL(IS,ICASE,K),
     &                    ERR2P(IS,ICASE,K),ERR2N(IS,ICASE,K),
     &                    CL(IS,ICASE,K),CERR(IS,ICASE,K),ES,EU,EC)
c        PRINT * ,'COMBINE after SLAVE: err2p,err2n',err2p(is,icase,k)
c     &    ,err2n(is,icase,k),is,icase,k
c        PRINT * ,'COMBINE after SLAVE: err2p,err2n',err2p(is,2,k)
c     &    ,err2n(is,2,k),is,2,k
*
*       Symmetrize uncertainties
*       (i.e. compute average of the two error matrices)
*
        DO J=IS,IS-1+NW**2
          ERR2(J,ICASE,K)=0.5D0*(ERR2P(J,ICASE,K)+ERR2N(J,ICASE,K))
          IF(XON(LSYMC)) THEN ! symmetrize uncertainties
            ERR2P(J,ICASE,K)=ERR2(J,ICASE,K)
            ERR2N(J,ICASE,K)=ERR2(J,ICASE,K)
          ENDIF
        ENDDO
*
*       Count number of failures
*
        IF(IS.EQ.1) CERR(0,ICASE,K)=0
        IF(CERR(IS,ICASE,K).NE.0) CERR(0,ICASE,K)=CERR(0,ICASE,K)+1
*
*       Printout
*
        IF(ICASE.EQ.2) THEN 
          ICAS2=0 ! i.e. no printout
        ELSE IF(ICASE.EQ.1.AND.XON(LQUST)) THEN
          ICAS2=2 ! i.e. printout of both cases
        ELSE
          ICAS2=ICASE ! i.e. printout of this case only
        ENDIF
        IF (CHROUT(1:15).NE.'DUMP_MASTER_INC')
     &  CALL PRINT_QUAN(ICAS2,CVAL (IS,ICASE,K),ERR2P(IS,ICASE,K),
     &                        ERR2N(IS,ICASE,K),ERR2 (IS,ICASE,K),
     &                        CL   (IS,ICASE,K),CERR (IS,ICASE,K))
*
*       The following is a special printout only for CHI2_SYM_RVK
*
        IF(CHROUT(1:12).EQ.'CHI2_SYM_RVK'.AND.CHSTEP.EQ.' ') THEN
          WRITE(LUNLOG,20042) 'Breakdown of errors on average:'
          WRITE(LUNLOG,2004) 'TOT     ','STAT    ','USYS    '
     &      ,(CHPARA(J),J=1,NCSYS)
          ETOT = ES*ES+EU*EU
          DO J=1,NCSYS
            ETOT = ETOT + EC(J)*EC(J)
          ENDDO
          WRITE(LUNLOG,20041) SQRT(ETOT),
     &      ES,EU,(EC(J),J=1,NCSYS)
          AA=CVAL(IS,ICASE,K)
          WRITE(LUNLOG,20042) 'Same thing as fraction of value:'
          WRITE(LUNLOG,20041) SQRT(ETOT)/AA,
     &      ES/AA,EU/AA,(EC(J)/AA,J=1,NCSYS)
 2004     FORMAT(
     &     T5,A8,T16,A8,T27,A8,T38,A8,T49,A8,T60,A8
     &    ,T71,A8,T82,A8,T93,A8,T104,A8)
20041     FORMAT(10F11.5)
20042     FORMAT(1X,A)
          WRITE(LUNLOG,'(A)') ' '
        ENDIF ! end special printout just for CHI2_SYM_RVK
*
      ENDDO
      END
*
************************************************************************
*
      SUBROUTINE PRINT_QUAN(NCASE,CVAL,ERR2P,ERR2N,ERR2,CL,CERR)
*     ==========================================================
*
*     Print result of average of more than 1 quantity (e.g. 2D average)
*
*     Input:   NCASE = number of cases
*                      NCASE < 1: print nothing 
*                      NCASE = 1: print just one case, the first case
*                                 (could be with or without systematics, 
*                                  usually with systematics)
*                      NCASE > 1: print two cases 
*                                 (with and without systematics)
*              CVAL  = array of combined values
*              ERR2P = error matrix (positive errors)
*              ERR2N = error matrix (negative errors)
*              ERR2  = error matrix (symmetric errors)
*              CL    = confidence level
*              CERR  = error code
*
      IMPLICIT NONE
      INCLUDE 'combos.inc'
      INCLUDE 'master.inc'
*
*     Arguments
*
      INTEGER NCASE
      INTEGER MCASE
      PARAMETER(MCASE=2)
      DOUBLE PRECISION CVAL (MSTEP,MCASE),
     &                 ERR2P(MQUAN,MQUAN,MCASE),
     &                 ERR2N(MQUAN,MQUAN,MCASE),
     &                 ERR2 (MQUAN,MQUAN,MCASE),
     &                 CL(MSTEP,MCASE)
      INTEGER CERR(0:MSTEP,MCASE)
*
*     Externals
*
      INTEGER LENOCC
*
*     Local variables
*
      LOGICAL STATONLY,SYSTONLY
      INTEGER IQUAN,ICASE,NCASE1
      CHARACTER*35 CH35
      CHARACTER*33 CH33(MQUAN)
      CHARACTER*12 CH12
      CHARACTER*9 CH9
      DOUBLE PRECISION TOT2P,TOT2N,TOT2,
     &                 STA2P,STA2N,STA2
      LOGICAL OLD_FORMAT
      DATA OLD_FORMAT/.FALSE./
*
      IF(NCASE.LE.0) RETURN
*
      IF(NQUAN.GT.2) THEN 
        CALL COMBOS_ERROR(0,
     &    'PRINT_QUAN cannot handle more than 2 quantities',
     &    'PRINT_QUAN will do nothing')
* NB: this routine should be easy to upgrade to print more than 2 quantities
        RETURN
      ENDIF
*
      IF(NCASE.GE.2) THEN 
        NCASE1=3
      ELSE
        NCASE1=1
      ENDIF
      DO ICASE=1,NCASE1
        STATONLY=ICASE.EQ.NCASE.AND.ICASE.NE.1
        SYSTONLY=ICASE.EQ.NCASE+1
        DO IQUAN=1,NQUAN
          CH12=' '
          CH9=' '
          CH33(IQUAN)=' ' 
          CH35=' '
          IF(.NOT.SYSTONLY) THEN
            IF(CERR(0,ICASE).NE.0) THEN
              WRITE(CH33(IQUAN),2000) CERR(0,ICASE)
 2000         FORMAT(4X,'***** error',I6,' *****')
            ELSE
              IF(ERR2P(IQUAN,IQUAN,ICASE).EQ.ERR2N(IQUAN,IQUAN,ICASE)) THEN
                WRITE(CH33(IQUAN),'(F11.5,''  +- '',F11.5)') CVAL(IQUAN,ICASE),
     &                                           DSQRT(ERR2(IQUAN,IQUAN,ICASE))
              ELSE
                WRITE(CH33(IQUAN),'(F11.5,SP,2F11.5)') CVAL(IQUAN,ICASE),
     &            +DSQRT(ERR2P(IQUAN,IQUAN,ICASE)),
     &            -DSQRT(ERR2N(IQUAN,IQUAN,ICASE))
              ENDIF
            ENDIF
            IF(.NOT.STATONLY) WRITE(CH35,2002)
     &       CHQUAN(IQUAN)(:LENOCC(CHQUAN(IQUAN)))
 2002       FORMAT(T20,A15,'=')
            IF(IQUAN.EQ.1) THEN 
              IF(CERR(0,ICASE).EQ.0.AND.CL(1,ICASE).GE.0.D0) THEN
                WRITE(CH12,'(A4,1X,F7.4)') 'CL =',CL(1,ICASE)
                WRITE(CH9,'(A3,F6.4)') 'CL=',CL(1,ICASE)
              ENDIF
              IF(.NOT.STATONLY) THEN
                CH35(:19)=' '//CHROUT//': '
              ELSE
                CH9(:3)='   '
                WRITE(CH35,2004) 'stat. only -->'
 2004           FORMAT(T20,A)
              ENDIF
            ELSE IF(IQUAN.EQ.2) THEN 
              IF(CERR(0,ICASE).EQ.0) THEN
                WRITE(CH12,'(A4,1X,SP,F7.4)') 'RHO=',
     &            ERR2(1,2,ICASE)/DSQRT(ERR2(1,1,ICASE)*ERR2(2,2,ICASE))
                WRITE(CH9,'(A2,SP,F7.4)') 'R=',
     &            ERR2(1,2,ICASE)/DSQRT(ERR2(1,1,ICASE)*ERR2(2,2,ICASE))
              ENDIF
            ELSE
              STOP 7676 ! this should never happen !
            ENDIF
          ELSE ! SYSTONLY
            IF(CERR(0,ICASE-2).NE.0.OR.CERR(0,ICASE-1).NE.0) THEN
              WRITE(CH33(IQUAN),2000) CERR(0,ICASE-2)+CERR(0,ICASE-1)
            ELSE
              TOT2P=ERR2P(IQUAN,IQUAN,ICASE-2)
              TOT2N=ERR2N(IQUAN,IQUAN,ICASE-2)
              TOT2 =ERR2 (IQUAN,IQUAN,ICASE-2)
              STA2P=ERR2P(IQUAN,IQUAN,ICASE-1)
              STA2N=ERR2N(IQUAN,IQUAN,ICASE-1)
              STA2 =ERR2 (IQUAN,IQUAN,ICASE-1)
              IF(TOT2P.EQ.TOT2N.AND.STA2P.EQ.STA2N) THEN 
                WRITE(CH33(IQUAN),'(11X,''  +- '',F11.5)') DSQRT(TOT2-STA2)
              ELSE
                WRITE(CH33(IQUAN),'(11X,SP,2F11.5)') 
     &            +DSQRT(TOT2P-STA2P),-DSQRT(TOT2N-STA2N)
              ENDIF
              IF(IQUAN.EQ.1) THEN
                WRITE(CH35,2004) 'syst. only -->'
              ELSE IF(IQUAN.EQ.2) THEN 
                WRITE(CH12,'(A4,1X,SP,F7.4)') 'RHO=',
     &                      (ERR2(1,2,ICASE-2)-ERR2(1,2,ICASE-1))/
     &                 SQRT((ERR2(1,1,ICASE-2)-ERR2(1,1,ICASE-1))*
     &                      (ERR2(2,2,ICASE-2)-ERR2(2,2,ICASE-1)))
                WRITE(CH9,'(A2,SP,F7.4)') 'R=',
     &                      (ERR2(1,2,ICASE-2)-ERR2(1,2,ICASE-1))/
     &                 SQRT((ERR2(1,1,ICASE-2)-ERR2(1,1,ICASE-1))*
     &                      (ERR2(2,2,ICASE-2)-ERR2(2,2,ICASE-1)))
              ELSE
                STOP 7677 ! this should never happen !
              ENDIF
            ENDIF
          ENDIF
          IF(.NOT.(SYSTONLY.AND.OLD_FORMAT)) THEN 
            IF(CHSTEP.NE.' '.AND..NOT.STATONLY.AND..NOT.SYSTONLY) THEN
              CH9(:3)='   '
              IF(OLD_FORMAT) THEN
                WRITE(LUNLOG,3006) ISTEP,VSTEP,CHROUT,CH33(IQUAN),CH9
              ELSE
                WRITE(LUNLOG,3006) ISTEP,VSTEP,CHROUT,CH33(IQUAN),CH12
              ENDIF
 3006         FORMAT(T2,I4,T8,F10.4,T20,A,T36,A,T72,A)
            ELSE 
              IF(OLD_FORMAT) THEN
                WRITE(LUNLOG,2006) CH35,CH33(IQUAN),CH9
              ELSE
                WRITE(LUNLOG,2006) CH35,CH33(IQUAN),CH12
              ENDIF
 2006         FORMAT(A,T36,A,T72,A)
            ENDIF
          ENDIF
        ENDDO
      ENDDO
      END
*
************************************************************************
*
      SUBROUTINE SLAVE(CHROUT,ICASE,NW,NQUAN,CVAL,ERR2P,ERR2N,CL,IERR,
     &   ES,EU,EC)
*     ================================================================
*
      IMPLICIT NONE
*
*     Arguments
*
      CHARACTER*(*) CHROUT
      CHARACTER*256 XCHROUT
      INTEGER NW,NQUAN
      DOUBLE PRECISION CVAL(NW,NW),ERR2P(NW,NW),ERR2N(NW,NW),CL
      DOUBLE PRECISION ES,EU,EC(*)
      INTEGER IERR 
      INTEGER ICASE
*
*     Externals
*
      INTEGER LENOCC
*
*     Local variables
*
      INTEGER I
*
      CALL UZERO(CVAL,1,NW**2)
      CALL UZERO(ERR2P,1,NW**2)
      CALL UZERO(ERR2N,1,NW**2)
      CL=-1.D0
      IERR=-1
*
      IF(NQUAN.NE.1) THEN ! only allow certain routines to be called
        IF(CHROUT.NE.'DUMP_MASTER_INC'.AND.
     &     CHROUT.NE.'CHI2_N_SYM') THEN
          XCHROUT = CHROUT 
          CALL COMBOS_ERROR(0,
     &     'Routine '//XCHROUT(:LENOCC(CHROUT))//
     &     ' cannot handle more than one measurement',
     &     'Use another combination routine')
          RETURN
        ENDIF
      ENDIF
*
      IF(CHROUT.EQ.'BLUE') THEN
        CALL BLUE(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'BLUE_ASYM') THEN
        CALL BLUE_ASYM(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'CHI2_SYM') THEN
        CALL CHI2_SYM(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'CHI2_SYM_RVK') THEN
        CALL CHI2_SYM_RVK(CVAL,ERR2P,ERR2N,CL,ES,EU,EC,IERR)
      ELSE IF(CHROUT.EQ.'CHI2_N_SYM') THEN
        CALL CHI2_N_SYM(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'CHI2_SYM_MIN') THEN
        CALL CHI2_SYM_MIN(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'CHI2_SYM_CIRC') THEN
        IF(ICASE.NE.2) THEN
          CALL CHI2_SYM_CIRC(CVAL,ERR2P,ERR2N,CL,IERR)
        ELSE ! systematics are ignored
          CALL CHI2_SYM(CVAL,ERR2P,ERR2N,CL,IERR)
          ! above call should give same result as CHI2_SYM_CIRC
        ENDIF
      ELSE IF(CHROUT.EQ.'CHI2_SYM_CIRC_G') THEN
        IF(ICASE.NE.2) THEN
          CALL CHI2_SYM_CIRC_G(CVAL,ERR2P,ERR2N,CL,IERR)
        ELSE ! systematics are ignored
          CALL CHI2_SYM(CVAL,ERR2P,ERR2N,CL,IERR)
          ! above call should give same result as CHI2_SYM_CIRC_G
        ENDIF
      ELSE IF(CHROUT.EQ.'CHI2_SYM_INDEP') THEN
        CALL CHI2_SYM_INDEP(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'CHI2_ASYM_MIN') THEN
        CALL CHI2_ASYM_MIN(CVAL,ICASE,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'COMBY_LIFETIME') THEN
        CALL COMBY_LIFETIME(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'DUMP_MASTER_INC') THEN
        CALL DUMP_MASTER_INC
      ELSE IF(CHROUT.EQ.'SINGLE') THEN
        CALL SINGLE(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE IF(CHROUT.EQ.'NEW_COMBINATION') THEN
        CALL NEW_COMBINATION(CVAL,ERR2P,ERR2N,CL,IERR)
      ELSE
        PRINT * ,'SLAVE: routine ',CHROUT,' not available'
        STOP 6633
      ENDIF
      IF(IERR.NE.0) THEN 
        CALL UZERO(CVAL,1,NW**2)
        CALL UZERO(ERR2P,1,NW**2)
        CALL UZERO(ERR2N,1,NW**2)
        CL=-1.D0
      ELSE
*       Perform various checks on error matrix (e.g. diagonal elements positive)
        DO I=1,MIN0(NQUAN,NW)
          XCHROUT = CHROUT
          IF(ERR2P(I,I).LE.0.D0) CALL COMBOS_ERROR(-1,
     &     'Diagonal element of ERR2P not positive',
     &     'Please check routine '//XCHROUT(:LENOCC(CHROUT)))   
          IF(ERR2N(I,I).LE.0.D0) CALL COMBOS_ERROR(-1,
     &     'Diagonal element of ERR2N not positive',
     &     'Please check routine '//XCHROUT(:LENOCC(CHROUT)))   
*OS       ERR2P(I,I)=+DABS(ERR2P(I,I)) ! force + sign on positive uncertainty
*OS       ERR2N(I,I)=-DABS(ERR2N(I,I)) ! force - sign on negative uncertainty
*zzz could check that matric is symmetric
*zzz could check that correlation coefficients are between -1 and 1
        ENDDO 
        IF(CL.LT.0.D0.OR.CL.GT.1.D0) CL=-1.D0 ! CL=-1 if not available
      ENDIF
c      PRINT * ,'SLAVE: err2p,err2n',err2p(1,1),err2n(1,1)
      END
*
************************************************************************
*
      SUBROUTINE DUMP_MASTER_INC
*     ==========================
*DR improved quite a bit when using several variables
*DR make full use of final error matrix
*     Dump content of common master.inc
*
      IMPLICIT NONE
*
*     Local variables
*
      INTEGER I,J
*
*     Externals
*
      INTEGER LENOCC
*      
      INCLUDE 'master.inc'
      DOUBLE PRECISION SYST(MMEAS),STASYS(MMEAS)
      DOUBLE PRECISION SYSCOR(MMEAS,MMEAS),TOTCOR(MMEAS,MMEAS)
      DOUBLE PRECISION SSUM
      INTEGER IMEAS,ISYS,JMEAS
*
      IF(LUNIT.LE.0) RETURN
      WRITE(LUNIT,3000)
 3000 FORMAT(/,1X,79('='),/,1X,'Dump of master.inc:')
      WRITE(LUNIT,1000) 'CHROUT',CHROUT,
     &                  'CHCOMB',CHCOMB(:LENOCC(CHCOMB)),
     &                  'CHMEAS',CHMEAS,
     &                  'CHSTEP',CHSTEP,'ISTEP',ISTEP,'VSTEP',VSTEP,
     &                  'LUNIT',LUNIT,
     &                  'NMEAS',NMEAS,'NQUAN',NQUAN,'NMEFF',NMEFF,
     &                  'NCSYS',NCSYS,'NPARA',NPARA
      WRITE(LUNIT,1100) 'CHANAL',
     &                  (CHANAL(I)(:LENOCC(CHANAL(I))),I=1,NMEAS)
 1000 FORMAT(4(/,1X,A6,' = ',A),
     &       1(/,1X,A6,' = ',I8),
     &       1(/,1X,A6,' = ',F10.4),
     &       6(/,1X,A6,' = ',I8))
 1100 FORMAT(1X,A6,' = ',(T11,A))
 1001 FORMAT(  /,1X,A6,' = ',(T10,20F14.7))
*DR
 1003 FORMAT(  /,1X,A6,' = ',(T10,20I8))
*DR 1002 FORMAT(                (T10,20F8.4))
 1002 FORMAT(1X,A6,' | ',(T10,20F14.7))
 1004 FORMAT(1X,I6,' | ',(T10,20F14.7))
      WRITE(LUNIT,1001) 'MEAS',(MEAS(I),I=1,NMEAS)
*DR
      WRITE(LUNIT,1003) 'QUAN',(KQUAN(I),I=1,NMEAS)
      WRITE(LUNIT,1001) 'STATP',(STATP(I),I=1,NMEAS)
      WRITE(LUNIT,1001) 'STATN',(STATN(I),I=1,NMEAS)
      WRITE(LUNIT,1001) 'STAT ',(STAT (I),I=1,NMEAS)
      WRITE(LUNIT,1001) 'USYSP',(USYSP(I),I=1,NMEAS)
      WRITE(LUNIT,1001) 'USYSN',(USYSN(I),I=1,NMEAS)
      WRITE(LUNIT,1001) 'USYS ',(USYS (I),I=1,NMEAS)
*DR better dump
      WRITE(LUNIT,'(/,A)') 'STACOR'

      DO J=1,NMEAS
        WRITE(LUNIT,1004) J,(STACOR(J,I),I=1,NMEAS)
      ENDDO

      WRITE(LUNIT,'(/,A)') 'CSYSP'
      DO J=1,NCSYS
        WRITE(LUNIT,1002) CHPARA(J),(CSYSP(I,J),I=1,NMEAS)
      ENDDO

      WRITE(LUNIT,'(/,A)') 'CSYSN'
      DO J=1,NCSYS
        WRITE(LUNIT,1002) CHPARA(J),(CSYSN(I,J),I=1,NMEAS)
      ENDDO

      WRITE(LUNIT,'(/,A)') 'CSYS'
      DO J=1,NCSYS
        WRITE(LUNIT,1002) CHPARA(J),(CSYS(I,J),I=1,NMEAS)
      ENDDO

*DR dump percentage error
      WRITE(LUNIT,'(/,A)') 'CSYS percentage error'
      DO J=1,NCSYS
        WRITE(LUNIT,1002) CHPARA(J),(CSYS(I,J)/MEAS(I)*100.,I=1,NMEAS)
      ENDDO
*DR

      WRITE(LUNIT,2000) 'CHPARA','PARA','EXCUP','EXCUN','EXCU'
 2000 FORMAT(/,1X,A,T20,4A10,/)
 2001 FORMAT(  1X,A,T20,4F10.4)
      DO I=1,NPARA
        WRITE(LUNIT,2001) CHPARA(I),PARA(I),EXCUP(I),EXCUN(I),EXCU(I)
      ENDDO

*DR write down summary of measured measurement
      CALL VZERO(SYST,MMEAS*2)
      CALL VZERO(STASYS,MMEAS*2)
      CALL VZERO(SYSCOR,MMEAS*MMEAS)
      CALL VZERO(TOTCOR,MMEAS*MMEAS)

      WRITE(LUNIT,*)' '
      WRITE(LUNIT,*)'Corrected measurements:'
      DO IMEAS=1,NMEAS
*summ systematics
*first uncorrelated one
CRVK-20050422 - square USYS here
        SYST(IMEAS)=USYS(IMEAS)**2
        DO ISYS=1,NCSYS
          SYST(IMEAS)=SYST(IMEAS)+CSYS(IMEAS,ISYS)**2
        ENDDO
*then correlated one
        STASYS(IMEAS)=SQRT(STAT(IMEAS)**2+SYST(IMEAS))
        SYST(IMEAS)=SQRT(SYST(IMEAS))

        WRITE(LUNIT,2010)  CHANAL(IMEAS)(:LENOCC(CHANAL(IMEAS))), 
     &    MEAS(IMEAS),STAT(IMEAS),SYST(IMEAS),STASYS(IMEAS)     
 2010 FORMAT(1X,A,T20,F14.7,'+/-',F14.7,'+/-',F14.7,' Tot Err:',F14.7)
      ENDDO


      WRITE(LUNIT,*)' ' 
*compute correlations if several quantities are measured
*assume quantities are store sequentially for each experiment
*assume systematics are 100% correlated
      IF (NQUAN.EQ.2) THEN
        DO IMEAS=1,NMEAS
          JMEAS=IMEAS+1
          IF (KQUAN(IMEAS).EQ.KQUAN(JMEAS)) THEN
              CALL COMBOS_ERROR(0,
     &'Quantities are the same','computing of correlation meaningless')
          ENDIF
          IF (STACOR(IMEAS,JMEAS).NE.0.) THEN
            SSUM=0.D0
            DO ISYS=1,NCSYS
              PRINT*,'DUMP_MASTER: CSYS=',CSYS(IMEAS,ISYS),CSYS(JMEAS,ISYS) 
              SSUM=SSUM+CSYS(IMEAS,ISYS)*CSYS(JMEAS,ISYS)
              PRINT*,'DUMP_MASTER: Prod=',CSYS(IMEAS,ISYS)*CSYS(JMEAS,ISYS),
     &                   ' SSUM=',SSUM
            ENDDO
            PRINT *, 'DUMP_MASTER: SYST=',SYST(IMEAS),SYST(JMEAS)
            SYSCOR(IMEAS,JMEAS)=SSUM/SYST(IMEAS)/SYST(JMEAS)
            PRINT *, 'DUMP_MASTER: SYSCOR=',SYSCOR(IMEAS,JMEAS)
            TOTCOR(IMEAS,JMEAS)=
     &          (SSUM+STACOR(IMEAS,JMEAS)*STAT(JMEAS)*STAT(IMEAS))/
     &           STASYS(IMEAS)/STASYS(JMEAS)
            PRINT *, 'DUMP_MASTER: SSUM+',
     &           STACOR(IMEAS,JMEAS),'*',STAT(JMEAS),'*',STAT(IMEAS),
     &           '=',SSUM+STACOR(IMEAS,JMEAS)*STAT(JMEAS)*STAT(IMEAS)
            PRINT *, 'DUMP_MASTER: TOTCOR=',
     &           SSUM+STACOR(IMEAS,JMEAS)*STAT(JMEAS)*STAT(IMEAS),
     &           '/(',STASYS(IMEAS),'*',STASYS(JMEAS),')=',
     &              TOTCOR(IMEAS,JMEAS)
            SYSCOR(JMEAS,IMEAS)=SYSCOR(IMEAS,JMEAS)
            TOTCOR(JMEAS,IMEAS)=TOTCOR(IMEAS,JMEAS)
C
            PRINT *, 'DUMP_MASTER: UNCOR(I)=SQRT(STAT(I)**2+USYS(I)**2) = ',
     &                     SQRT(STAT(IMEAS)**2+USYS(IMEAS)**2)
            PRINT *, 'DUMP_MASTER: UNCOR(J)=SQRT(STAT(J)**2+USYS(J)**2) = ',
     &                     SQRT(STAT(JMEAS)**2+USYS(JMEAS)**2)
            PRINT *, 'DUMP_MASTER: STACOR*STAT(I)*STAT(J)/',
     &                     '(UNCOR(I)*UNCOR(J)) = ',
     &             STACOR(IMEAS,JMEAS)*STAT(JMEAS)*STAT(IMEAS)/
     &             SQRT(STAT(IMEAS)**2+USYS(IMEAS)**2)/
     &             SQRT(STAT(JMEAS)**2+USYS(JMEAS)**2)

          ENDIF
        ENDDO
      ENDIF

*DR better dump
      WRITE(LUNIT,'(/,A)') 'SYSCOR'
      DO J=1,NMEAS
        WRITE(LUNIT,1004) J,(SYSCOR(J,I),I=1,NMEAS)
      ENDDO
      WRITE(LUNIT,'(/,A)') 'TOTCOR'
      DO J=1,NMEAS
        WRITE(LUNIT,1004) J,(TOTCOR(J,I),I=1,NMEAS)
      ENDDO

    

*DR end
      END
